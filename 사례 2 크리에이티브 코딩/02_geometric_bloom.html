<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>Geometric Bloom</title>
  <style>
    * { margin: 0; padding: 0; }
    body { background: #050510; overflow: hidden; }
    canvas { display: block; }
    #info {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255,255,255,0.35);
      font-family: monospace;
      font-size: 13px;
      letter-spacing: 0.1em;
      pointer-events: none;
    }
  </style>
</head>
<body>
<canvas id="c"></canvas>
<div id="info">클릭하면 새 패턴 · 마우스로 색상 변경</div>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

let W = canvas.width = window.innerWidth;
let H = canvas.height = window.innerHeight;

window.addEventListener('resize', () => {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
  initBloom();
});

// ── 설정 ────────────────────────────────────────────────
let cx = W / 2;
let cy = H / 2;
let baseHue = 200;
let frame = 0;
let rings = [];

// ── 링 생성 ─────────────────────────────────────────────
class Ring {
  constructor(sides, radius, speed, offset, depth) {
    this.sides = sides;
    this.radius = radius;
    this.speed = speed;
    this.angle = offset;
    this.depth = depth;
    this.scale = 0;
    this.targetScale = 1;
    this.born = frame;
  }

  update() {
    this.angle += this.speed;
    // 등장 애니메이션
    if (this.scale < this.targetScale) {
      this.scale += 0.025;
      if (this.scale > this.targetScale) this.scale = this.targetScale;
    }
  }

  draw(hue) {
    const r = this.radius * this.scale;
    const pts = [];

    for (let i = 0; i < this.sides; i++) {
      const a = (i / this.sides) * Math.PI * 2 + this.angle;
      pts.push({ x: cx + Math.cos(a) * r, y: cy + Math.sin(a) * r });
    }

    const layerHue = hue + this.depth * 25;
    const alpha = 0.6 - this.depth * 0.08;

    ctx.save();
    ctx.globalAlpha = Math.max(0.1, alpha);
    ctx.strokeStyle = `hsl(${layerHue}, 80%, 70%)`;
    ctx.lineWidth = 1.5 - this.depth * 0.1;
    ctx.shadowBlur = 12;
    ctx.shadowColor = `hsl(${layerHue}, 90%, 65%)`;

    ctx.beginPath();
    pts.forEach((p, i) => i === 0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y));
    ctx.closePath();
    ctx.stroke();

    // 연결선 (중심 → 꼭짓점)
    if (this.depth < 3) {
      ctx.globalAlpha = alpha * 0.3;
      ctx.lineWidth = 0.5;
      pts.forEach(p => {
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.lineTo(p.x, p.y);
        ctx.stroke();
      });
    }

    // 꼭짓점 점
    ctx.globalAlpha = alpha * 0.8;
    ctx.fillStyle = `hsl(${layerHue + 30}, 90%, 85%)`;
    ctx.shadowBlur = 8;
    pts.forEach(p => {
      ctx.beginPath();
      ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
      ctx.fill();
    });

    ctx.restore();
  }
}

// ── 꽃잎 파티클 ─────────────────────────────────────────
class Petal {
  constructor() {
    const angle = Math.random() * Math.PI * 2;
    const dist = Math.random() * 80 + 20;
    this.x = cx + Math.cos(angle) * dist;
    this.y = cy + Math.sin(angle) * dist;
    this.vx = (Math.random() - 0.5) * 0.8;
    this.vy = (Math.random() - 0.5) * 0.8;
    this.size = Math.random() * 3 + 1;
    this.life = 1;
    this.decay = Math.random() * 0.008 + 0.003;
    this.hue = Math.random() * 80 + 160;
  }

  update() {
    this.x += this.vx;
    this.y += this.vy;
    this.vy += 0.01; // 중력
    this.life -= this.decay;
  }

  draw() {
    ctx.save();
    ctx.globalAlpha = this.life * 0.7;
    ctx.shadowBlur = 10;
    ctx.shadowColor = `hsl(${this.hue}, 90%, 70%)`;
    ctx.fillStyle = `hsl(${this.hue}, 80%, 80%)`;
    ctx.beginPath();
    ctx.arc(this.x, this.y, Math.max(0, this.size * this.life), 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  isDead() { return this.life <= 0; }
}

// ── 초기화 ──────────────────────────────────────────────
let petals = [];

function initBloom() {
  cx = W / 2;
  cy = H / 2;
  rings = [];

  const configs = [
    { sides: 3,  radius: 60,  speed:  0.008, offset: 0 },
    { sides: 4,  radius: 100, speed: -0.006, offset: Math.PI / 4 },
    { sides: 6,  radius: 145, speed:  0.004, offset: 0 },
    { sides: 5,  radius: 185, speed: -0.005, offset: Math.PI / 5 },
    { sides: 8,  radius: 220, speed:  0.003, offset: Math.PI / 8 },
    { sides: 12, radius: 260, speed: -0.002, offset: 0 },
    { sides: 6,  radius: 300, speed:  0.0025, offset: Math.PI / 6 },
    { sides: 3,  radius: 340, speed: -0.003, offset: Math.PI / 3 },
  ];

  configs.forEach((c, i) => {
    rings.push(new Ring(c.sides, c.radius, c.speed, c.offset, i));
  });
}

initBloom();

// 클릭 → 새 패턴 + 폭발
canvas.addEventListener('click', e => {
  cx = e.clientX;
  cy = e.clientY;

  baseHue = Math.random() * 360;
  rings = [];
  const configs = [
    { sides: Math.floor(Math.random() * 4) + 3, radius: 50,  speed:  0.008 },
    { sides: Math.floor(Math.random() * 4) + 3, radius: 95,  speed: -0.006 },
    { sides: Math.floor(Math.random() * 5) + 4, radius: 140, speed:  0.005 },
    { sides: Math.floor(Math.random() * 5) + 4, radius: 185, speed: -0.004 },
    { sides: Math.floor(Math.random() * 6) + 5, radius: 230, speed:  0.003 },
    { sides: Math.floor(Math.random() * 8) + 6, radius: 275, speed: -0.002 },
    { sides: Math.floor(Math.random() * 6) + 4, radius: 315, speed:  0.0025 },
    { sides: Math.floor(Math.random() * 4) + 3, radius: 355, speed: -0.003 },
  ];
  configs.forEach((c, i) => {
    rings.push(new Ring(c.sides, c.radius, c.speed, Math.random() * Math.PI * 2, i));
  });

  // 꽃잎 폭발
  for (let i = 0; i < 40; i++) petals.push(new Petal());
});

// 마우스 → 색상 변경
window.addEventListener('mousemove', e => {
  baseHue = (e.clientX / W) * 360;
});

// ── 중심 장식 ────────────────────────────────────────────
function drawCenter(hue) {
  ctx.save();
  const pulse = 8 + Math.sin(frame * 0.05) * 3;
  const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, pulse * 2);
  grad.addColorStop(0, `hsl(${hue}, 80%, 90%)`);
  grad.addColorStop(1, `hsla(${hue}, 80%, 70%, 0)`);
  ctx.fillStyle = grad;
  ctx.shadowBlur = 20;
  ctx.shadowColor = `hsl(${hue}, 90%, 80%)`;
  ctx.beginPath();
  ctx.arc(cx, cy, pulse, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();
}

// ── 루프 ────────────────────────────────────────────────
function loop() {
  frame++;

  // 잔상
  ctx.fillStyle = 'rgba(5, 5, 16, 0.18)';
  ctx.fillRect(0, 0, W, H);

  const hue = baseHue + Math.sin(frame * 0.01) * 30;

  rings.forEach(r => { r.update(); r.draw(hue); });
  drawCenter(hue);

  // 주기적 꽃잎
  if (frame % 12 === 0) petals.push(new Petal());
  petals = petals.filter(p => !p.isDead());
  petals.forEach(p => { p.update(); p.draw(); });

  requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>
