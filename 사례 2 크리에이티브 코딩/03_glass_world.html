<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>Glass World ✨</title>
  <style>
    * { margin: 0; padding: 0; }
    body { overflow: hidden; }
    canvas { display: block; }
    #hint {
      position: fixed;
      bottom: 22px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255,255,255,0.52);
      font-family: 'Segoe UI', sans-serif;
      font-size: 14px;
      letter-spacing: 0.07em;
      pointer-events: none;
    }
  </style>
</head>
<body>
<canvas id="c"></canvas>
<div id="hint">클릭하면 오브젝트 생성 ✨</div>
<script>
const cv  = document.getElementById('c');
const ctx = cv.getContext('2d');
let W = cv.width  = window.innerWidth;
let H = cv.height = window.innerHeight;

window.addEventListener('resize', () => {
  W = cv.width  = window.innerWidth;
  H = cv.height = window.innerHeight;
  buildClouds();
});

// ── 경로 함수들 ────────────────────────────────────────────
function pCircle(x, y, r) {
  ctx.beginPath();
  ctx.arc(x, y, r, 0, Math.PI * 2);
}

function pStar(x, y, outerR, innerR, rot) {
  ctx.beginPath();
  for (let i = 0; i < 10; i++) {
    const r = i % 2 === 0 ? outerR : innerR;
    const a = (i / 10) * Math.PI * 2 + rot;
    i === 0
      ? ctx.moveTo(x + Math.cos(a) * r, y + Math.sin(a) * r)
      : ctx.lineTo(x + Math.cos(a) * r, y + Math.sin(a) * r);
  }
  ctx.closePath();
}

function pHeart(x, y, s) {
  ctx.beginPath();
  for (let i = 0; i <= 64; i++) {
    const t  = (i / 64) * Math.PI * 2;
    const px = x + 16 * Math.pow(Math.sin(t), 3) * (s / 16);
    const py = y - (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) * (s / 14);
    i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
  }
  ctx.closePath();
}

// type: 0=circle, 1=star, 2=heart
function makePath(type, x, y, r, rot) {
  if      (type === 0) pCircle(x, y, r);
  else if (type === 1) pStar(x, y, r, r * 0.42, rot);
  else                 pHeart(x, y, r * 0.88);
}

// ── 유리 오브젝트 렌더링 ────────────────────────────────────
function drawGlass(type, x, y, r, hue, rot) {
  ctx.save();

  // ① 반투명 유리 바디
  makePath(type, x, y, r, rot);
  const bg = ctx.createRadialGradient(x - r*.22, y - r*.22, 0, x, y, r * 1.06);
  bg.addColorStop(0,   `hsla(${hue}, 55%, 92%, .18)`);
  bg.addColorStop(.55, `hsla(${hue}, 55%, 87%, .08)`);
  bg.addColorStop(1,   `hsla(${hue+15}, 60%, 82%, .13)`);
  ctx.fillStyle = bg;
  ctx.fill();

  // ② 내부 등고선 (인플레이터블 튜브 느낌)
  for (let i = 1; i <= 4; i++) {
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(1 - i * .1, 1 - i * .1);
    ctx.translate(-x, -y);
    makePath(type, x, y, r, rot);
    ctx.strokeStyle = `rgba(195, 220, 255, ${.22 - i * .03})`;
    ctx.lineWidth   = .8;
    ctx.stroke();
    ctx.restore();
  }

  // ③ 이리데슨트 테두리 (무지개빛 레이어)
  ctx.save();
  [0, 45, 100, 165, 225].forEach((dh, i) => {
    makePath(type, x, y, r, rot);
    ctx.strokeStyle  = `hsla(${(hue + dh) % 360}, 90%, 82%, ${.68 - i * .09})`;
    ctx.lineWidth    = Math.max(.4, 2.9 - i * .48);
    ctx.shadowBlur   = i === 0 ? 14 : 0;
    ctx.shadowColor  = `hsla(${hue}, 90%, 88%, .65)`;
    ctx.stroke();
  });
  ctx.restore();

  // ④ 흰색 하이라이트 (클립 적용)
  ctx.save();
  makePath(type, x, y, r, rot);
  ctx.clip();
  const hl = ctx.createRadialGradient(
    x - r * .32, y - r * .38, 0,
    x - r * .32, y - r * .38, r * .55
  );
  hl.addColorStop(0,   'rgba(255,255,255,.88)');
  hl.addColorStop(.42, 'rgba(255,255,255,.28)');
  hl.addColorStop(1,   'rgba(255,255,255,0)');
  ctx.fillStyle = hl;
  ctx.fillRect(x - r*2, y - r*2, r*4, r*4);
  ctx.restore();

  // ⑤ 하단 반사 점
  ctx.save();
  makePath(type, x, y, r, rot);
  ctx.clip();
  ctx.beginPath();
  ctx.ellipse(x + r*.18, y + r*.52, r*.17, r*.065, -.25, 0, Math.PI*2);
  ctx.fillStyle = 'rgba(255,255,255,.38)';
  ctx.fill();
  ctx.restore();

  ctx.restore();
}

// ── 배경 ───────────────────────────────────────────────────
let clouds = [];

function buildClouds() {
  clouds = Array.from({ length: 6 }, () => ({
    x: Math.random() * W,
    y: Math.random() * H * .65,
    r: Math.random() * 175 + 70,
    a: Math.random() * .1 + .04
  }));
}
buildClouds();

function drawBG() {
  const g = ctx.createLinearGradient(0, 0, W * .35, H);
  g.addColorStop(0,   '#c5d8f8');
  g.addColorStop(.28, '#c0c4f2');
  g.addColorStop(.62, '#b5cbf5');
  g.addColorStop(1,   '#d4c4f4');
  ctx.fillStyle = g;
  ctx.fillRect(0, 0, W, H);

  clouds.forEach(c => {
    const cg = ctx.createRadialGradient(c.x, c.y, 0, c.x, c.y, c.r);
    cg.addColorStop(0, `rgba(255,255,255,${c.a})`);
    cg.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle = cg;
    ctx.fillRect(0, 0, W, H);
  });
}

// ── 스파클 ─────────────────────────────────────────────────
class Sparkle {
  constructor(x, y) {
    this.x   = x  ?? Math.random() * W;
    this.y   = y  ?? Math.random() * H;
    this.s   = Math.random() * 11 + 4;
    this.t   = 0;
    this.max = Math.random() * 80 + 40;
    this.rot = Math.random() * Math.PI * .5;
  }
  update() { this.t++; }
  draw() {
    const a = Math.sin((this.t / this.max) * Math.PI);
    if (a <= 0) return;
    const s = this.s;
    ctx.save();
    ctx.globalAlpha  = a * .9;
    ctx.strokeStyle  = '#ffffff';
    ctx.lineWidth    = 1.5;
    ctx.shadowBlur   = 5;
    ctx.shadowColor  = 'rgba(210,235,255,.85)';
    ctx.translate(this.x, this.y);
    ctx.rotate(this.rot);
    // 십자 (4방향)
    [[1,0],[0,1],[-1,0],[0,-1]].forEach(([dx,dy]) => {
      ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(dx*s, dy*s); ctx.stroke();
    });
    // 대각 (얇게)
    ctx.globalAlpha = a * .45;
    ctx.lineWidth   = .8;
    const d = s * .55, sq = Math.SQRT2;
    [[1,1],[-1,1],[-1,-1],[1,-1]].forEach(([dx,dy]) => {
      ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(dx*d/sq, dy*d/sq); ctx.stroke();
    });
    ctx.restore();
  }
  isDead() { return this.t >= this.max; }
}

// ── 유리 오브젝트 클래스 ────────────────────────────────────
const TYPES = [0, 0, 0, 1, 1, 2]; // 0=circle 더 많이
let frame = 0;

class GObj {
  constructor(x, y, type) {
    this.type  = type  ?? TYPES[Math.floor(Math.random() * TYPES.length)];
    this.x     = x     ?? Math.random() * W;
    this.y     = y     ?? H + 80;
    this.r     = Math.random() * 52 + 22;
    this.hue   = Math.random() * 65 + 185;
    this.vx    = (Math.random() - .5) * .5;
    this.vy    = -(Math.random() * .75 + .25);
    this.wo    = Math.random() * Math.PI * 2; // wobble offset
    this.ws    = Math.random() * .02  + .007; // wobble speed
    this.rot   = Math.random() * Math.PI * 2;
    this.rs    = (Math.random() - .5) * .006;
    this.alpha = 0;
    this.tgt   = Math.random() * .28 + .58;
  }
  update() {
    this.wo  += this.ws;
    this.x   += this.vx + Math.sin(this.wo) * .35;
    this.y   += this.vy;
    this.rot += this.rs;
    if (this.alpha < this.tgt) this.alpha = Math.min(this.alpha + .012, this.tgt);
  }
  draw() {
    ctx.save();
    ctx.globalAlpha = this.alpha;
    drawGlass(this.type, this.x, this.y, this.r, this.hue, this.rot);
    ctx.restore();
  }
  isOff() { return this.y < -this.r * 3; }
}

// ── 초기화 ─────────────────────────────────────────────────
let objs   = [];
let sparks = [];

for (let i = 0; i < 9; i++) {
  const o = new GObj(Math.random() * W, Math.random() * H * .9);
  o.alpha = o.tgt;
  objs.push(o);
}

for (let i = 0; i < 18; i++) {
  const s = new Sparkle();
  s.t = Math.floor(Math.random() * s.max);
  sparks.push(s);
}

cv.addEventListener('click', e => {
  [0, 1, 2].forEach(type => {
    objs.push(new GObj(
      e.clientX + (Math.random() - .5) * 90,
      e.clientY + (Math.random() - .5) * 90,
      type
    ));
  });
  for (let i = 0; i < 6; i++) {
    sparks.push(new Sparkle(
      e.clientX + (Math.random() - .5) * 70,
      e.clientY + (Math.random() - .5) * 70
    ));
  }
});

// ── 메인 루프 ───────────────────────────────────────────────
function loop() {
  frame++;
  drawBG();

  if (frame % 140 === 0 && objs.length < 14) objs.push(new GObj());
  if (frame % 18  === 0) sparks.push(new Sparkle());

  objs = objs.filter(o => !o.isOff());
  objs.sort((a, b) => b.r - a.r); // 큰 것이 뒤에
  objs.forEach(o => { o.update(); o.draw(); });

  sparks = sparks.filter(s => !s.isDead());
  sparks.forEach(s => { s.update(); s.draw(); });

  requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>
