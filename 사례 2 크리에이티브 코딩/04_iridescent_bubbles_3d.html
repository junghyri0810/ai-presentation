<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>Iridescent Bubbles 3D ğŸ«§</title>
  <style>
    * { margin: 0; padding: 0; }
    body {
      overflow: hidden;
      background: linear-gradient(135deg, #b8cef0, #c0c8f5 50%, #d0c5f5);
    }
    canvas { display: block; }
    #hint {
      position: fixed; bottom: 22px; left: 50%;
      transform: translateX(-50%);
      color: rgba(255,255,255,.55);
      font-family: 'Segoe UI', sans-serif;
      font-size: 14px; letter-spacing: .07em; pointer-events: none;
    }
  </style>
</head>
<body>
<div id="hint">ë²„ë¸” ìœ„ í´ë¦­í•˜ë©´ íŒ! Â· ë¹ˆ ê³³ í´ë¦­í•˜ë©´ ìƒì„± ğŸ«§</div>

<script type="importmap">
{ "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/"
} }
</script>

<script type="module">
import * as THREE from 'three';
import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';

// â”€â”€ ë Œë”ëŸ¬ & ì”¬ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.1;
document.body.appendChild(renderer.domElement);

const scene  = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 200);
camera.position.set(0, 0, 16);

window.addEventListener('resize', () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

// â”€â”€ í™˜ê²½ë§µ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const pmrem = new THREE.PMREMGenerator(renderer);
scene.environment = pmrem.fromScene(new RoomEnvironment(renderer), 0.04).texture;
pmrem.dispose();

// â”€â”€ ì¡°ëª… â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
scene.add(new THREE.AmbientLight(0xc0d8ff, 3.0));

const dl1 = new THREE.DirectionalLight(0xffffff, 4.0);
dl1.position.set(6, 12, 8);
scene.add(dl1);

const dl2 = new THREE.DirectionalLight(0xc8c0ff, 1.5);
dl2.position.set(-6, -4, 6);
scene.add(dl2);

// â”€â”€ ê³µìœ  ì§€ì˜¤ë©”íŠ¸ë¦¬ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const sphereGeo  = new THREE.SphereGeometry(1, 64, 64);
const popDotGeo  = new THREE.SphereGeometry(0.07, 8, 8);

// â”€â”€ ë¹„ëˆ„ê±°í’ˆ ì¬ì§ˆ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function makeBubbleMat(hue) {
  return new THREE.MeshPhysicalMaterial({
    color: new THREE.Color().setHSL(hue / 360, .40, .88),
    transmission: 0.95,
    roughness: 0.02,
    metalness: 0,
    ior: 1.45,
    thickness: 0.6,
    envMapIntensity: 2.5,
    iridescence: 1.0,
    iridescenceIOR: 1.40,
    iridescenceThicknessRange: [60, 900],
    transparent: true,
    opacity: 0.9,
    side: THREE.DoubleSide,
  });
}

// â”€â”€ íŒ íŒŒí‹°í´ ë²„ìŠ¤íŠ¸ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class PopBurst {
  constructor(pos, hue, r) {
    this.t    = 0;
    this.max  = 42;
    this.dots = [];

    for (let i = 0; i < 22; i++) {
      const mat = new THREE.MeshBasicMaterial({
        color: new THREE.Color().setHSL(((hue + i * 17) % 360) / 360, .8, .8),
        transparent: true,
      });
      const mesh = new THREE.Mesh(popDotGeo, mat);
      mesh.position.copy(pos);

      const phi   = Math.random() * Math.PI * 2;
      const theta = Math.random() * Math.PI;
      const spd   = (Math.random() * .1 + .05) * r;
      mesh.userData.v = new THREE.Vector3(
        Math.sin(theta) * Math.cos(phi) * spd,
        Math.sin(theta) * Math.sin(phi) * spd,
        Math.cos(theta) * spd
      );

      scene.add(mesh);
      this.dots.push(mesh);
    }
  }

  update() {
    this.t++;
    const p = this.t / this.max;
    this.dots.forEach(m => {
      m.position.addScaledVector(m.userData.v, 1);
      m.userData.v.y -= .004;
      m.material.opacity = 1 - p;
      m.scale.setScalar(Math.max(0, 1 - p * .8));
    });
  }

  isDead() { return this.t >= this.max; }

  dispose() {
    this.dots.forEach(m => {
      scene.remove(m);
      m.material.dispose();
    });
  }
}

// â”€â”€ ë²„ë¸” í´ë˜ìŠ¤ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class Bubble {
  constructor(px, py, pz) {
    this.hue  = Math.random() * 80 + 185;
    this.r    = Math.random() * .7 + .35;
    this.mesh = new THREE.Mesh(sphereGeo, makeBubbleMat(this.hue));
    this.mesh.scale.setScalar(this.r);
    this.mesh.position.set(
      px ?? (Math.random() - .5) * 16,
      py ?? -12 - Math.random() * 4,
      pz ?? (Math.random() - .5) * 5
    );

    this.vy = Math.random() * .018 + .007;
    this.vx = (Math.random() - .5) * .006;
    this.wo = Math.random() * Math.PI * 2;
    this.ws = Math.random() * .015 + .005;

    scene.add(this.mesh);
  }

  update() {
    this.wo += this.ws;
    this.mesh.position.x += this.vx + Math.sin(this.wo) * .015;
    this.mesh.position.y += this.vy;
    this.mesh.rotation.y  += .003;
  }

  isOff() { return this.mesh.position.y > 13; }

  dispose() {
    scene.remove(this.mesh);
    this.mesh.material.dispose();
  }
}

// â”€â”€ ë§ˆìš°ìŠ¤ & ì¸í„°ë™ì…˜ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const mouse      = new THREE.Vector2();
const mouseLerp  = { x: 0, y: 0 };
const raycaster  = new THREE.Raycaster();
const clickPlane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);

window.addEventListener('mousemove', e => {
  mouse.x =  (e.clientX / innerWidth)  * 2 - 1;
  mouse.y = -(e.clientY / innerHeight) * 2 + 1;
});

let bubbles = [];
let bursts  = [];

renderer.domElement.addEventListener('click', e => {
  const ndc = new THREE.Vector2(
    (e.clientX / innerWidth)  * 2 - 1,
    -(e.clientY / innerHeight) * 2 + 1
  );
  raycaster.setFromCamera(ndc, camera);

  // ë²„ë¸” ìœ„ í´ë¦­: íŒ!
  const meshes = bubbles.map(b => b.mesh);
  const hits   = raycaster.intersectObjects(meshes);
  if (hits.length > 0) {
    const idx = bubbles.findIndex(b => b.mesh === hits[0].object);
    if (idx !== -1) {
      const b = bubbles[idx];
      bursts.push(new PopBurst(b.mesh.position.clone(), b.hue, b.r));
      b.dispose();
      bubbles.splice(idx, 1);
    }
  } else {
    // ë¹ˆ ê³³ í´ë¦­: ìƒˆ ë²„ë¸” ìƒì„±
    const target = new THREE.Vector3();
    raycaster.ray.intersectPlane(clickPlane, target);
    for (let i = 0; i < 4; i++) {
      bubbles.push(new Bubble(
        target.x + (Math.random() - .5) * 3,
        target.y + (Math.random() - .5) * 3,
        target.z + (Math.random() - .5) * 2
      ));
    }
  }
});

// â”€â”€ ì´ˆê¸° ë²„ë¸” ë°°ì¹˜ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
for (let i = 0; i < 18; i++) {
  const b = new Bubble();
  b.mesh.position.y = (Math.random() - .5) * 22;
  bubbles.push(b);
}

// â”€â”€ ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let frame = 0;

function animate() {
  frame++;
  requestAnimationFrame(animate);

  // ë§ˆìš°ìŠ¤ íŒ¨ëŸ´ë™ìŠ¤
  mouseLerp.x += (mouse.x - mouseLerp.x) * .04;
  mouseLerp.y += (mouse.y - mouseLerp.y) * .04;
  camera.position.x += (mouseLerp.x * 1.5 - camera.position.x) * .04;
  camera.position.y += (mouseLerp.y * 1.0 - camera.position.y) * .04;
  camera.lookAt(0, 0, 0);

  // ë²„ë¸” ì—…ë°ì´íŠ¸
  for (let i = bubbles.length - 1; i >= 0; i--) {
    bubbles[i].update();
    if (bubbles[i].isOff()) {
      bubbles[i].dispose();
      bubbles.splice(i, 1);
    }
  }

  if (frame % 90 === 0 && bubbles.length < 22) bubbles.push(new Bubble());

  // íŒ ë²„ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
  for (let i = bursts.length - 1; i >= 0; i--) {
    bursts[i].update();
    if (bursts[i].isDead()) {
      bursts[i].dispose();
      bursts.splice(i, 1);
    }
  }

  renderer.render(scene, camera);
}

animate();
</script>
</body>
</html>
